    // Constantes
    const CONFIG = {
        CONTRACT_ADDRESS: "0x619aBD3Ab24C8a8a13f15E6DAaa2c31D02267184",
        PLP_ADDRESS: "0xe5c56E4a8f8d96e3A91b18D83b7f0c36663C9a74",
        PWR_ADDRESS: "0x3Eb3B7b3D95Cb3699295D7868F85e43b56AeeFcB",
        DESIRED_NETWORK_ID: 369,
        CACHE_TTL: 30000, // 30 segundos
        MAX_RETRIES: 3,
        BASE_GAS_MULTIPLIER: 1.6,
        MIN_PLS_BALANCE: 0.01,
        DEBOUNCE_MS: 300
    };

    // Estado global
    let state = {
        web3: null,
        account: null,
        contract: null,
        plpContract: null,
        pwrContract: null,
        spwrContract: null,
        selectedProvider: null,
        pendingClaimStakeId: null,
        cache: { prices: {}, balances: {}, apr: null },
        transactionHistory: [],
        isProcessing: false
    };

    // ABI
    const powerStakeABI = [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_plpToken",
                    "type": "address"
                },
                {
                    "internalType": "address",
                    "name": "_pwrToken",
                    "type": "address"
                },
                {
                    "internalType": "address",
                    "name": "_spwrToken",
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "user",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "Claimed",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "user",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "duration",
                    "type": "uint256"
                }
            ],
            "name": "Staked",
            "type": "event"
        },
        {
            "anonymous": false,
            "inputs": [
                {
                    "indexed": true,
                    "internalType": "address",
                    "name": "user",
                    "type": "address"
                },
                {
                    "indexed": false,
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "Withdrawn",
            "type": "event"
        },
        {
            "inputs": [],
            "name": "TOTAL_REWARDS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "stakeId",
                    "type": "uint256"
                }
            ],
            "name": "calculateReward",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "stakeId",
                    "type": "uint256"
                }
            ],
            "name": "claimRewards",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "duration",
                    "type": "uint256"
                }
            ],
            "name": "createStake",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "currentAPR",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "stakeId",
                    "type": "uint256"
                }
            ],
            "name": "earlyWithdrawStake",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "stakeId",
                    "type": "uint256"
                }
            ],
            "name": "getStakeDetails",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "address",
                            "name": "owner",
                            "type": "address"
                        },
                        {
                            "internalType": "uint256",
                            "name": "plpAmount",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "startTime",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "endTime",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "duration",
                            "type": "uint256"
                        },
                        {
                            "internalType": "bool",
                            "name": "claimed",
                            "type": "bool"
                        }
                    ],
                    "internalType": "struct PowerStake.Stake",
                    "name": "",
                    "type": "tuple"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "user",
                    "type": "address"
                }
            ],
            "name": "getUserStakes",
            "outputs": [
                {
                    "internalType": "uint256[]",
                    "name": "",
                    "type": "uint256[]"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "plpToken",
            "outputs": [
                {
                    "internalType": "contract IERC20",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "pwrToken",
            "outputs": [
                {
                    "internalType": "contract IERC20",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "rewardsDistributed",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "spwrToken",
            "outputs": [
                {
                    "internalType": "contract IERC20",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "stakeId",
                    "type": "uint256"
                }
            ],
            "name": "withdrawStake",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ];
    const erc20ABI = [
        {
            "constant": true,
            "inputs": [
                {
                    "name": "_owner",
                    "type": "address"
                }
            ],
            "name": "balanceOf",
            "outputs": [
                {
                    "name": "balance",
                    "type": "uint256"
                }
            ],
            "payable": false,
            "stateMutability": "view",
            "type": "function"
        },
        {
            "constant": true,
            "inputs": [
                {
                    "name": "_owner",
                    "type": "address"
                },
                {
                    "name": "_spender",
                    "type": "address"
                }
            ],
            "name": "allowance",
            "outputs": [
                {
                    "name": "",
                    "type": "uint256"
                }
            ],
            "payable": false,
            "stateMutability": "view",
            "type": "function"
        },
        {
            "constant": false,
            "inputs": [
                {
                    "name": "_spender",
                    "type": "address"
                },
                {
                    "name": "_value",
                    "type": "uint256"
                }
            ],
            "name": "approve",
            "outputs": [
                {
                    "name": "",
                    "type": "bool"
                }
            ],
            "payable": false,
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ];

    // Utilidades
    function log(category, message, data = {}) {
        console.log(`[${new Date().toISOString()}] [${category}] ${message}`, data);
    }

    function sanitizeInput(input) {
        const div = document.createElement('div');
        div.textContent = input;
        return div.innerHTML;
    }

    function debounce(func, wait) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func(...args), wait);
        };
    }

    function showNotification(message, isError = false) {
        const notification = document.createElement('div');
        notification.className = `notification ${isError ? 'error' : 'success'}`;
        notification.innerHTML = message;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 5000);
    }

    function addTransactionToHistory(type, txHash, details) {
        state.transactionHistory.unshift({ type, txHash, details, timestamp: Date.now() });
        if (state.transactionHistory.length > 5) state.transactionHistory.pop();
        updateTransactionHistory();
    }

    function updateTransactionHistory() {
        const historyUl = document.getElementById('transactionHistory');
        historyUl.innerHTML = state.transactionHistory.map(tx => `
            <li>
                ${tx.type} (${new Date(tx.timestamp).toLocaleTimeString()}): 
                ${tx.details} 
                <a href="https://scan.pulsechain.com/tx/${tx.txHash}" target="_blank">[Tx]</a>
            </li>
        `).join('');
    }

    // Inicialización
    async function init() {
        log('INIT', 'Initializing application');
        if (!window.ethereum) {
            showNotification('No wallet detected. Install MetaMask or Rabby Wallet.', true);
            log('INIT', 'No Ethereum provider detected');
            return;
        }
        document.getElementById('connectWallet').addEventListener('click', detectWallets);
        document.getElementById('stakeButton').addEventListener('click', stakePLP);
        document.getElementById('stakeAmount').addEventListener('input', debounce(updateStakeButtonState, CONFIG.DEBOUNCE_MS));
        document.getElementById('stakePeriod').addEventListener('change', debounce(updateStakeButtonState, CONFIG.DEBOUNCE_MS));
        await updateAllData();
        setInterval(updateAllData, CONFIG.CACHE_TTL);
        log('INIT', 'Initialization complete');
    }

    async function detectWallets() {
        log('WALLET', 'Detecting wallets');
        const providers = window.ethereum?.providers || (window.ethereum ? [window.ethereum] : []);
        const walletOptions = document.getElementById('walletOptions');
        walletOptions.innerHTML = '';
        if (!providers.length) {
            walletOptions.innerHTML = '<p>No wallets detected.</p>';
            showNotification('No wallets detected. Install MetaMask or Rabby.', true);
            log('WALLET', 'No wallets detected');
            return;
        }
        providers.forEach((provider, index) => {
            const walletName = provider.isMetaMask ? 'MetaMask' : provider.isRabby ? 'Rabby Wallet' : `Wallet ${index + 1}`;
            const button = document.createElement('button');
            button.className = 'wallet-option';
            button.innerText = walletName;
            button.onclick = () => connectWallet(provider, walletName);
            walletOptions.appendChild(button);
        });
        document.getElementById('walletModal').style.display = 'block';
        log('WALLET', 'Wallet modal displayed', { providerCount: providers.length });
    }

    function closeWalletModal() {
        document.getElementById('walletModal').style.display = 'none';
        log('WALLET', 'Wallet modal closed');
    }

    async function connectWallet(provider, walletName) {
        try {
            log('WALLET', `Connecting to ${walletName}`);
            state.selectedProvider = provider;
            state.web3 = new Web3(provider);
            const accounts = await provider.request({ method: 'eth_requestAccounts' });
            if (!accounts.length) throw new Error('No account selected');
            state.account = accounts[0];
            document.getElementById('account').innerText = `${state.account.slice(0, 6)}...${state.account.slice(-4)}`;
            showNotification(`Connected with ${walletName}`);
            await initializeContracts();
            await updateAllData();
            provider.on('accountsChanged', handleAccountsChanged);
            provider.on('chainChanged', () => window.location.reload());
            closeWalletModal();
        } catch (error) {
            log('WALLET', `Connect error with ${walletName}`, { error });
            showNotification(`Error connecting: ${error.message}`, true);
        }
    }

    async function initializeContracts() {
        try {
            log('CONTRACT', 'Initializing contracts');
            if (!state.web3) throw new Error('Web3 not initialized');
            const networkId = await state.web3.eth.net.getId();
            if (Number(networkId) !== CONFIG.DESIRED_NETWORK_ID) {
                await switchToPulseChain();
            }
            state.contract = new state.web3.eth.Contract(powerStakeABI, CONFIG.CONTRACT_ADDRESS);
            state.plpContract = new state.web3.eth.Contract(erc20ABI, CONFIG.PLP_ADDRESS);
            state.pwrContract = new state.web3.eth.Contract(erc20ABI, CONFIG.PWR_ADDRESS);
            const spwrAddress = await state.contract.methods.spwrToken().call();
            state.spwrContract = new state.web3.eth.Contract(erc20ABI, spwrAddress);
            log('CONTRACT', 'Contracts initialized', { spwrAddress });
        } catch (error) {
            log('CONTRACT', 'Initialize contracts error', { error });
            showNotification(`Error initializing contracts: ${error.message}`, true);
        }
    }

    async function switchToPulseChain() {
        try {
            log('NETWORK', 'Switching to PulseChain');
            await state.selectedProvider.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: `0x${CONFIG.DESIRED_NETWORK_ID.toString(16)}` }],
            });
        } catch (switchError) {
            if (switchError.code === 4902) {
                await state.selectedProvider.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: `0x${CONFIG.DESIRED_NETWORK_ID.toString(16)}`,
                        chainName: 'PulseChain',
                        nativeCurrency: { name: 'Pulse', symbol: 'PLS', decimals: 18 },
                        rpcUrls: ['https://rpc.pulsechain.com'],
                        blockExplorerUrls: ['https://scan.pulsechain.com']
                    }]
                });
            } else {
                throw switchError;
            }
        }
    }

    async function handleAccountsChanged(accounts) {
        state.account = accounts[0] || null;
        document.getElementById('account').innerText = state.account ? `${state.account.slice(0, 6)}...${state.account.slice(-4)}` : 'Not connected';
        showNotification(state.account ? `Account changed: ${state.account.slice(0, 6)}...` : 'Wallet disconnected', !state.account);
        if (state.account) await updateAllData();
    }

    async function updateAllData() {
        try {
            log('DATA', 'Updating all data');
            await Promise.all([
                updateTokenPrices(),
                state.account && updateBalances(),
                state.account && updateStakesTable(),
                updateTotalRewards()
            ]);
        } catch (error) {
            log('DATA', 'Error updating data', { error });
            showNotification('Error updating data', true);
        }
    }

    async function updateTokenPrices() {
        const now = Date.now();
        if (state.cache.prices.pwr && now - state.cache.prices.pwr.timestamp < CONFIG.CACHE_TTL) {
            document.getElementById('pwrPrice').innerText = state.cache.prices.pwr.value.toFixed(4);
            return;
        }
        try {
            log('PRICE', 'Fetching PWR price');
            const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${CONFIG.PWR_ADDRESS}`);
            const data = await response.json();
            if (!data.pairs?.length) throw new Error('No trading pairs found');
            const priceUsd = parseFloat(data.pairs[0].priceUsd);
            if (isNaN(priceUsd)) throw new Error('Invalid price');
            state.cache.prices.pwr = { value: priceUsd, timestamp: now };
            document.getElementById('pwrPrice').innerText = priceUsd.toFixed(4);
            document.getElementById('pwrPrice').classList.remove('skeleton');
            log('PRICE', 'PWR price updated', { priceUsd });
        } catch (error) {
            log('PRICE', 'Error fetching PWR price', { error });
            document.getElementById('pwrPrice').innerText = 'Unavailable';
        }
    }

    async function updateBalances() {
        try {
            log('BALANCE', 'Updating balances');
            const batch = new state.web3.eth.BatchRequest();
            const balances = {};
            batch.add(state.plpContract.methods.balanceOf(state.account).call.request({}, (err, res) => {
                balances.plp = err ? '0' : res;
            }));
            batch.add(state.spwrContract.methods.balanceOf(state.account).call.request({}, (err, res) => {
                balances.spwr = err ? '0' : res;
            }));
            await batch.execute();
            const plpBalance = parseFloat(state.web3.utils.fromWei(balances.plp, 'ether')).toFixed(4);
            const spwrBalance = parseFloat(state.web3.utils.fromWei(balances.spwr, 'ether')).toFixed(4);
            state.cache.balances = { plp: plpBalance, spwr: spwrBalance, timestamp: Date.now() };
            document.getElementById('plpBalance').innerText = plpBalance;
            document.getElementById('spwrBalance').innerText = spwrBalance;
            document.getElementById('plpBalance').classList.remove('skeleton');
            document.getElementById('spwrBalance').classList.remove('skeleton');
            log('BALANCE', 'Balances updated', { plpBalance, spwrBalance });
        } catch (error) {
            log('BALANCE', 'Error updating balances', { error });
            showNotification('Error loading balances', true);
        }
    }

    async function updateTotalRewards() {
        try {
            log('REWARDS', 'Updating total rewards');
            const batch = new state.web3.eth.BatchRequest();
            let totalRewards, rewardsDistributed, currentAPR;
            batch.add(state.contract.methods.TOTAL_REWARDS().call.request({}, (err, res) => {
                totalRewards = err ? '0' : res;
            }));
            batch.add(state.contract.methods.rewardsDistributed().call.request({}, (err, res) => {
                rewardsDistributed = err ? '0' : res;
            }));
            batch.add(state.contract.methods.currentAPR().call.request({}, (err, res) => {
                currentAPR = err ? '50' : res;
            }));
            await batch.execute();
            const remainingRewards = parseFloat(state.web3.utils.fromWei(
                state.web3.utils.toBN(totalRewards).sub(state.web3.utils.toBN(rewardsDistributed)),
                'ether'
            )).toLocaleString();
            state.cache.apr = { value: currentAPR, timestamp: Date.now() };
            document.getElementById('totalRewards').innerText = remainingRewards;
            document.getElementById('aprYield').innerText = `${currentAPR}%`;
            document.getElementById('totalRewards').classList.remove('skeleton');
            document.getElementById('aprYield').classList.remove('skeleton');
            log('REWARDS', 'Total rewards updated', { remainingRewards, currentAPR });
        } catch (error) {
            log('REWARDS', 'Error updating rewards', { error });
            showNotification('Error loading rewards', true);
        }
    }

    async function stakePLP() {
        if (state.isProcessing) return;
        state.isProcessing = true;
        const stakeButton = document.getElementById('stakeButton');
        stakeButton.classList.add('loading');
        try {
            log('STAKE', 'Initiating stake');
            if (!state.account) throw new Error('Wallet not connected');
            const amount = sanitizeInput(document.getElementById('stakeAmount').value);
            const periodDays = document.getElementById('stakePeriod').value;
            if (!amount || !periodDays || parseFloat(amount) <= 0) throw new Error('Invalid amount or period');
            const amountWei = state.web3.utils.toWei(amount, 'ether');
            const durationSeconds = parseInt(periodDays) * 24 * 60 * 60;

            // Validar saldos
            const plsBalance = parseFloat(state.web3.utils.fromWei(await state.web3.eth.getBalance(state.account), 'ether'));
            if (plsBalance < CONFIG.MIN_PLS_BALANCE) throw new Error(`Insufficient PLS for gas: ${plsBalance.toFixed(4)} PLS`);
            const plpBalance = await state.plpContract.methods.balanceOf(state.account).call();
            if (state.web3.utils.toBN(plpBalance).lt(state.web3.utils.toBN(amountWei))) {
                throw new Error(`Insufficient PLP balance: ${state.web3.utils.fromWei(plpBalance, 'ether')} PLP`);
            }

            // Aprobar PLP
            const allowance = await state.plpContract.methods.allowance(state.account, CONFIG.CONTRACT_ADDRESS).call();
            if (state.web3.utils.toBN(allowance).lt(state.web3.utils.toBN(amountWei))) {
                showNotification('Approving PLP...');
                const approvalTx = await retryTransaction(() =>
                    state.plpContract.methods.approve(CONFIG.CONTRACT_ADDRESS, amountWei).send({
                        from: state.account,
                        gas: Math.floor((await state.plpContract.methods.approve(CONFIG.CONTRACT_ADDRESS, amountWei).estimateGas({ from: state.account })) * CONFIG.BASE_GAS_MULTIPLIER),
                        gasPrice: await state.web3.eth.getGasPrice()
                    })
                );
                addTransactionToHistory('Approval', approvalTx.transactionHash, `Approved ${amount} PLP`);
                showNotification(`PLP Approved: <a href="https://scan.pulsechain.com/tx/${approvalTx.transactionHash}" target="_blank">View Tx</a>`);
            }

            // Crear stake
            showNotification('Creating stake...');
            const stakeTx = await retryTransaction(() =>
                state.contract.methods.createStake(amountWei, durationSeconds).send({
                    from: state.account,
                    gas: Math.floor((await state.contract.methods.createStake(amountWei, durationSeconds).estimateGas({ from: state.account })) * CONFIG.BASE_GAS_MULTIPLIER),
                    gasPrice: await state.web3.eth.getGasPrice()
                })
            );
            addTransactionToHistory('Stake', stakeTx.transactionHash, `Staked ${amount} PLP for ${periodDays} days`);
            showNotification(`Stake created: <a href="https://scan.pulsechain.com/tx/${stakeTx.transactionHash}" target="_blank">View Tx</a>`);

            // Actualizar datos
            await updateAllData();
            document.getElementById('stakeAmount').value = '';
            document.getElementById('stakePeriod').value = '';
            updateStakeButtonState();
            confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ['#ffdd00', '#00cc99'] });
        } catch (error) {
            log('STAKE', 'Stake error', { error });
            showNotification(`Stake failed: ${error.message}`, true);
        } finally {
            state.isProcessing = false;
            stakeButton.classList.remove('loading');
        }
    }

    async function retryTransaction(fn, retries = CONFIG.MAX_RETRIES) {
        let attempt = 0;
        while (attempt < retries) {
            try {
                const nonce = await state.web3.eth.getTransactionCount(state.account, 'pending');
                const tx = await fn({ nonce });
                const receipt = await state.web3.eth.getTransactionReceipt(tx.transactionHash);
                if (!receipt || !receipt.status) throw new Error('Transaction reverted');
                return tx;
            } catch (error) {
                attempt++;
                log('TX', `Attempt ${attempt} failed`, { error });
                if (attempt >= retries) throw error;
                await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
            }
        }
    }

    function updateStakeButtonState() {
        const amount = document.getElementById('stakeAmount').value;
        const period = document.getElementById('stakePeriod').value;
        const isDisabled = !state.account || !amount || parseFloat(amount) <= 0 || !period || state.isProcessing;
        document.getElementById('stakeButton').disabled = isDisabled;
        updateYieldEstimate();
        log('UI', 'Stake button state updated', { isDisabled });
    }

    function updateYieldEstimate() {
        const amount = parseFloat(document.getElementById('stakeAmount').value) || 0;
        const periodDays = parseInt(document.getElementById('stakePeriod').value) || 0;
        if (!amount || !periodDays) {
            document.getElementById('totalYield').innerText = '0%';
            return;
        }
        const bonus = {30: 0, 60: 10, 90: 20, 180: 40, 360: 80}[periodDays] || 0;
        const apr = parseInt(state.cache.apr?.value || 50) + bonus;
        const yieldEstimate = (amount * apr / 100) * (periodDays / 365);
        document.getElementById('totalYield').innerText = `${yieldEstimate.toFixed(2)} PWR`;
    }

    async function updateStakesTable() {
        log('STAKES', 'Updating stakes table');
        const tbody = document.getElementById('stakesTable');
        tbody.innerHTML = '<tr><td colspan="7" class="no-data"><span class="skeleton"></span></td></tr>';
        if (!state.account || !state.contract) {
            tbody.innerHTML = '<tr><td colspan="7" class="no-data">Connect wallet to view stakes</td></tr>';
            log('STAKES', 'No account or contract available');
            return;
        }
        try {
            const stakeIds = await state.contract.methods.getUserStakes(state.account).call();
            log('STAKES', 'Fetched stake IDs', { stakeIds });
            if (!stakeIds || !stakeIds.length) {
                tbody.innerHTML = '<tr><td colspan="7" class="no-data">No active stakes found</td></tr>';
                log('STAKES', 'No stakes found for account');
                return;
            }
            tbody.innerHTML = '';
            const validStakeIds = stakeIds.filter(id => id > 0);
            log('STAKES', 'Filtered valid stake IDs', { validStakeIds });
            if (!validStakeIds.length) {
                tbody.innerHTML = '<tr><td colspan="7" class="no-data">No valid stakes found</td></tr>';
                log('STAKES', 'No valid stakes after filtering');
                return;
            }
            for (const stakeId of validStakeIds) {
                log('STAKES', `Processing stake ID: ${stakeId}`);
                try {
                    const stake = await state.contract.methods.getStakeDetails(stakeId).call();
                    log('STAKES', `Stake details for ID ${stakeId}`, { stake });
                    if (stake.claimed || stake.owner.toLowerCase() !== state.account.toLowerCase()) {
                        log('STAKES', `Skipping stake ID ${stakeId}: already claimed or not owned`, { claimed: stake.claimed, owner: stake.owner });
                        continue;
                    }
                    const amount = parseFloat(state.web3.utils.fromWei(stake.plpAmount, 'ether')).toFixed(4);
                    const startDate = new Date(stake.startTime * 1000).toLocaleString();
                    const endDate = new Date(stake.endTime * 1000).toLocaleString();
                    const timeRemaining = Math.max(0, stake.endTime - Math.floor(Date.now() / 1000));
                    const periodDays = stake.duration / (24 * 60 * 60);
                    const bonus = {30: 0, 60: 10, 90: 20, 180: 40, 360: 80}[periodDays] || 0;
                    const apr = parseInt(state.cache.apr?.value || 50) + bonus;
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${stakeId}</td>
                        <td>${amount} PLP</td>
                        <td>${startDate}</td>
                        <td>${endDate}</td>
                        <td><span class="timer" id="timer-${stakeId}">${formatTimeRemaining(timeRemaining)}</span></td>
                        <td>${apr}%</td>
                        <td>
                            ${timeRemaining > 0 
                                ? `<button onclick="earlyWithdraw(${stakeId})" ${state.isProcessing ? 'disabled' : ''}>Early Withdraw</button>`
                                : `<button class="claim-all-btn" onclick="showConfirmClaimModal(${stakeId})" ${state.isProcessing ? 'disabled' : ''}>Claim All</button>`}
                        </td>
                    `;
                    tbody.appendChild(row);
                    if (timeRemaining > 0) {
                        startTimer(stakeId, stake.endTime);
                    }
                } catch (error) {
                    log('STAKES', `Error processing stake ID ${stakeId}`, { error });
                    continue;
                }
            }
            log('STAKES', 'Stakes table updated', { stakeCount: validStakeIds.length });
        } catch (error) {
            log('STAKES', 'Error updating stakes', { error });
            tbody.innerHTML = '<tr><td colspan="7" class="no-data">Error loading stakes</td></tr>';
            showNotification('Error loading stakes', true);
        }
    }

    function formatTimeRemaining(seconds) {
        if (seconds <= 0) return 'Finished';
        const days = Math.floor(seconds / (24 * 60 * 60));
        const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));
        const minutes = Math.floor((seconds % (60 * 60)) / 60);
        return `${days}d ${hours}h ${minutes}m`;
    }

    function startTimer(stakeId, endTime) {
        const timerInterval = setInterval(() => {
            const remaining = Math.max(0, endTime - Math.floor(Date.now() / 1000));
            const timerElement = document.getElementById(`timer-${stakeId}`);
            if (timerElement) {
                timerElement.innerText = formatTimeRemaining(remaining);
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    updateStakesTable();
                }
            } else {
                clearInterval(timerInterval);
            }
        }, 1000);
    }

    async function earlyWithdraw(stakeId) {
        if (state.isProcessing) return;
        state.isProcessing = true;
        try {
            log('WITHDRAW', `Initiating early withdraw for Stake ID: ${stakeId}`);
            showNotification('Processing early withdrawal...');
            const tx = await retryTransaction(() =>
                state.contract.methods.earlyWithdrawStake(stakeId).send({
                    from: state.account,
                    gas: Math.floor((await state.contract.methods.earlyWithdrawStake(stakeId).estimateGas({ from: state.account })) * CONFIG.BASE_GAS_MULTIPLIER),
                    gasPrice: await state.web3.eth.getGasPrice()
                })
            );
            addTransactionToHistory('Early Withdraw', tx.transactionHash, `Withdrew Stake ID ${stakeId}`);
            showNotification(`Early withdrawal completed: <a href="https://scan.pulsechain.com/tx/${tx.transactionHash}" target="_blank">View Tx</a>`);
            await updateAllData();
        } catch (error) {
            log('WITHDRAW', 'Early withdraw error', { error });
            showNotification(`Early withdraw failed: ${error.message}`, true);
        } finally {
            state.isProcessing = false;
        }
    }

    function showConfirmClaimModal(stakeId) {
        log('CLAIM', `Showing confirm claim modal for Stake ID: ${stakeId}`);
        if (!stakeId || isNaN(stakeId) || stakeId <= 0) {
            log('CLAIM', 'Invalid stakeId detected', { stakeId, isNaN: isNaN(stakeId), isZeroOrLess: stakeId <= 0 });
            showNotification('Error: Invalid stake ID. Stake IDs must be greater than 0.', true);
            return;
        }
        state.pendingClaimStakeId = parseInt(stakeId);
        log('CLAIM', `Set pendingClaimStakeId to: ${state.pendingClaimStakeId}`);
        document.getElementById('confirmStakeId').innerText = stakeId;
        document.getElementById('confirmClaimMessage').innerHTML = 'Loading stake details...';
        state.contract.methods.getStakeDetails(stakeId).call().then(stake => {
            log('CLAIM', `Fetched stake details for ID ${stakeId}`, { stake });
            const plpAmount = parseFloat(state.web3.utils.fromWei(stake.plpAmount, 'ether')).toFixed(4);
            state.contract.methods.calculateReward(stakeId).call().then(reward => {
                const rewardAmount = parseFloat(state.web3.utils.fromWei(reward, 'ether')).toFixed(4);
                log('CLAIM', `Calculated reward for Stake ID ${stakeId}`, { rewardAmount });
                document.getElementById('confirmClaimMessage').innerHTML = `Claim <strong>${plpAmount} PLP</strong> and <strong>${rewardAmount} PWR</strong> for Stake ID ${stakeId}?`;
            }).catch(error => {
                log('CLAIM', `Error calculating reward for Stake ID ${stakeId}`, { error });
                document.getElementById('confirmClaimMessage').innerHTML = `Claim PLP and PWR for Stake ID ${stakeId}?`;
            });
        }).catch(error => {
            log('CLAIM', `Error fetching stake details for ID ${stakeId}`, { error });
            showNotification(`Error loading stake details: ${error.message}`, true);
            document.getElementById('confirmClaimMessage').innerHTML = `Claim PLP and PWR for Stake ID ${stakeId}?`;
        });
        document.getElementById('confirmClaimModal').style.display = 'block';
        log('CLAIM', 'Confirm claim modal displayed', { stakeId });
    }

    function closeConfirmClaimModal() {
        document.getElementById('confirmClaimModal').style.display = 'none';
        state.pendingClaimStakeId = null;
        log('CLAIM', 'Confirm claim modal closed');
    }

    async function proceedClaimAll() {
        if (state.isProcessing) {
            log('CLAIM', 'Transaction already in progress');
            return;
        }
        state.isProcessing = true;
        const stakeId = state.pendingClaimStakeId;
        log('CLAIM', 'Proceeding with claim', { stakeId });
        if (!stakeId || isNaN(stakeId) || stakeId <= 0) {
            log('CLAIM', 'Invalid stakeId in proceedClaimAll', { stakeId });
            showNotification('Error: Invalid stake ID. Please try again.', true);
            closeConfirmClaimModal();
            state.isProcessing = false;
            return;
        }
        try {
            closeConfirmClaimModal();
            if (!state.account) throw new Error('Wallet not connected');
            const networkId = await state.web3.eth.net.getId();
            if (Number(networkId) !== CONFIG.DESIRED_NETWORK_ID) throw new Error('Switch to PulseChain (ID: 369)');

            // Validar stake
            log('CLAIM', `Fetching stake details for ID ${stakeId}`);
            const stake = await state.contract.methods.getStakeDetails(stakeId).call();
            log('CLAIM', 'Stake details', { stake });
            const plpAmount = parseFloat(state.web3.utils.fromWei(stake.plpAmount, 'ether')).toFixed(4);
            const rewardAmount = parseFloat(state.web3.utils.fromWei(await state.contract.methods.calculateReward(stakeId).call(), 'ether')).toFixed(4);
            if (Math.max(0, stake.endTime - Math.floor(Date.now() / 1000)) > 0) throw new Error('Stake still active');
            if (stake.claimed) throw new Error('Stake already claimed');
            if (stake.owner.toLowerCase() !== state.account.toLowerCase()) throw new Error('Not stake owner');

            // Validar saldos
            const plsBalance = parseFloat(state.web3.utils.fromWei(await state.web3.eth.getBalance(state.account), 'ether'));
            if (plsBalance < CONFIG.MIN_PLS_BALANCE) throw new Error(`Insufficient PLS: ${plsBalance.toFixed(4)} PLS`);
            const contractPLPBalance = parseFloat(state.web3.utils.fromWei(await state.plpContract.methods.balanceOf(CONFIG.CONTRACT_ADDRESS).call(), 'ether'));
            if (contractPLPBalance < plpAmount) throw new Error(`Contract PLP balance low: ${contractPLPBalance} PLP`);
            const contractPWRBalance = parseFloat(state.web3.utils.fromWei(await state.pwrContract.methods.balanceOf(CONFIG.CONTRACT_ADDRESS).call(), 'ether'));
            if (contractPWRBalance < rewardAmount) throw new Error(`Contract PWR balance low: ${contractPWRBalance} PWR`);

            // Withdraw
            showNotification(`Withdrawing ${plpAmount} PLP...`);
            log('CLAIM', `Initiating withdraw for Stake ID ${stakeId}`);
            const withdrawTx = await retryTransaction(() =>
                state.contract.methods.withdrawStake(stakeId).send({
                    from: state.account,
                    gas: Math.floor((await state.contract.methods.withdrawStake(stakeId).estimateGas({ from: state.account })) * CONFIG.BASE_GAS_MULTIPLIER),
                    gasPrice: await state.web3.eth.getGasPrice()
                })
            );
            addTransactionToHistory('Withdraw', withdrawTx.transactionHash, `Withdrew ${plpAmount} PLP`);
            showNotification(`Withdrawn ${plpAmount} PLP: <a href="https://scan.pulsechain.com/tx/${withdrawTx.transactionHash}" target="_blank">View Tx</a>`);

            // Claim rewards
            showNotification(`Claiming ${rewardAmount} PWR...`);
            log('CLAIM', `Initiating claim for Stake ID ${stakeId}`);
            const claimTx = await retryTransaction(() =>
                state.contract.methods.claimRewards(stakeId).send({
                    from: state.account,
                    gas: Math.floor((await state.contract.methods.claimRewards(stakeId).estimateGas({ from: state.account })) * CONFIG.BASE_GAS_MULTIPLIER),
                    gasPrice: await state.web3.eth.getGasPrice()
                })
            );
            addTransactionToHistory('Claim', claimTx.transactionHash, `Claimed ${rewardAmount} PWR`);
            showNotification(`Claimed ${rewardAmount} PWR: <a href="https://scan.pulsechain.com/tx/${claimTx.transactionHash}" target="_blank">View Tx</a>`);

            // Efecto visual
            confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ['#ffdd00', '#00cc99'] });

            // Actualizar datos
            await updateAllData();
        } catch (error) {
            log('CLAIM', 'Claim error', { error });
            showNotification(`Claim failed: ${error.message}`, true);
        } finally {
            state.isProcessing = false;
        }
    }

    function showWhyInvest() {
        const modal = document.getElementById('whyInvestModal');
        const content = document.getElementById('whyInvestContent');
        content.innerHTML = `
            <h3>Why Stake PLP?</h3>
            <p>Staking PLP allows you to earn PWR rewards with attractive APRs.</p>
            <p>Benefits include:</p>
            <ul style="text-align: left; margin: 10px 0;">
                <li>High yield opportunities</li>
                <li>Flexible staking periods</li>
                <li>Secure and transparent on PulseChain</li>
            </ul>
        `;
        modal.style.display = 'block';
        log('UI', 'Why Invest modal displayed');
    }

    function closeWhyInvestModal() {
        document.getElementById('whyInvestModal').style.display = 'none';
        log('UI', 'Why Invest modal closed');
    }

    // Iniciar aplicación
    init();
</script>
